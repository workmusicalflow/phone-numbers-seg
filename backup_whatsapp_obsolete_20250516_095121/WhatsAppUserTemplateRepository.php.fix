<?php

namespace App\Repositories\Doctrine\WhatsApp;

use App\Entities\WhatsApp\WhatsAppUserTemplate;
use App\Repositories\Doctrine\BaseRepository;
use App\Repositories\Interfaces\WhatsApp\WhatsAppUserTemplateRepositoryInterface;
use Doctrine\ORM\EntityManagerInterface;
use InvalidArgumentException;
use Psr\Log\LoggerInterface;

/**
 * Repository Doctrine pour les templates WhatsApp utilisateur
 */
class WhatsAppUserTemplateRepository extends BaseRepository implements WhatsAppUserTemplateRepositoryInterface
{
    private ?LoggerInterface $logger;

    /**
     * Constructeur
     *
     * @param EntityManagerInterface $entityManager
     * @param LoggerInterface|null $logger
     */
    public function __construct(EntityManagerInterface $entityManager, ?LoggerInterface $logger = null)
    {
        parent::__construct($entityManager, WhatsAppUserTemplate::class);
        $this->logger = $logger;
    }

    /**
     * Log un message avec contexte si le logger est disponible
     *
     * @param string $level
     * @param string $message
     * @param array $context
     * @return void
     */
    private function log(string $level, string $message, array $context = []): void
    {
        if ($this->logger) {
            $this->logger->{$level}($message, $context);
        }
    }

    /**
     * Enregistre un template WhatsApp utilisateur
     *
     * @param mixed $template
     * @return mixed
     */
    public function save($template)
    {
        if (!$template instanceof WhatsAppUserTemplate) {
            throw new InvalidArgumentException('Expected instance of WhatsAppUserTemplate');
        }
        
        $this->log('debug', 'Sauvegarde d\'un template WhatsApp', [
            'templateName' => $template->getTemplateName(),
            'userId' => $template->getUser()->getId(),
        ]);
        
        $this->getEntityManager()->persist($template);
        $this->getEntityManager()->flush();
        return $template;
    }

    /**
     * Trouve tous les templates d'un utilisateur
     *
     * @param int $userId
     * @param int $limit
     * @param int $offset
     * @return array
     */
    public function findByUser(int $userId, int $limit = 50, int $offset = 0): array
    {
        $this->log('info', 'Récupération des templates WhatsApp pour l\'utilisateur', [
            'userId' => $userId,
            'limit' => $limit,
            'offset' => $offset,
        ]);

        try {
            // NIVEAU 1: Approche avec QueryBuilder et JOIN sur l'entité User
            $this->log('debug', 'Tentative de récupération via QueryBuilder avec relation User');
            
            $queryBuilder = $this->getEntityManager()->createQueryBuilder();
            $query = $queryBuilder->select('t')
                ->from(WhatsAppUserTemplate::class, 't')
                ->join('t.user', 'u')
                ->where('u.id = :userId')
                ->setParameter('userId', $userId)
                ->orderBy('t.createdAt', 'DESC')
                ->setMaxResults($limit)
                ->setFirstResult($offset)
                ->getQuery();

            try {
                $this->log('debug', 'Exécution de la requête DQL');
                $result = $query->getResult();
                $this->log('info', 'Templates récupérés avec succès via DQL', ['count' => count($result)]);
                return $result;
            } catch (\Exception $e) {
                // Si la requête DQL échoue, passons à une requête SQL directe
                $this->log('warning', 'Échec de la requête DQL, tentative avec SQL direct', [
                    'error' => $e->getMessage()
                ]);

                // NIVEAU 2: Approche SQL directe
                $this->log('debug', 'Tentative de récupération via SQL direct');
                
                $conn = $this->getEntityManager()->getConnection();
                $stmt = $conn->prepare('
                    SELECT
                        t.id,
                        t.user_id AS userId,
                        t.template_name AS templateName,
                        t.language_code AS languageCode,
                        t.body_variables_count AS bodyVariablesCount,
                        t.has_header_media AS hasHeaderMedia,
                        t.is_special_template AS isSpecialTemplate,
                        t.header_media_url AS headerMediaUrl,
                        t.created_at AS createdAt,
                        t.updated_at AS updatedAt
                    FROM
                        whatsapp_user_templates t
                    WHERE
                        t.user_id = ?
                    ORDER BY
                        t.created_at DESC
                    LIMIT ? OFFSET ?
                ');

                $results = $stmt->executeQuery([$userId, $limit, $offset])->fetchAllAssociative();
                $this->log('info', 'Templates récupérés avec succès via SQL direct', ['count' => count($results)]);

                // Transformer les résultats en objets WhatsAppUserTemplate
                $templates = [];
                foreach ($results as $row) {
                    $template = new WhatsAppUserTemplate();
                    $reflectionClass = new \ReflectionClass(WhatsAppUserTemplate::class);

                    // Définir l'ID
                    $idProperty = $reflectionClass->getProperty('id');
                    $idProperty->setAccessible(true);
                    $idProperty->setValue($template, (int)$row['id']);

                    // Définir le reste des propriétés
                    $template
                        ->setTemplateName($row['templateName'])
                        ->setLanguageCode($row['languageCode'])
                        ->setBodyVariablesCount($row['bodyVariablesCount'] !== null ? (int)$row['bodyVariablesCount'] : null)
                        ->setHasHeaderMedia((bool)$row['hasHeaderMedia'])
                        ->setIsSpecialTemplate((bool)$row['isSpecialTemplate'])
                        ->setHeaderMediaUrl($row['headerMediaUrl']);

                    // Créer l'utilisateur et le lier
                    $userRepository = $this->getEntityManager()->getRepository(\App\Entities\User::class);
                    $user = $userRepository->find($userId);
                    if ($user) {
                        $template->setUser($user);
                    } else {
                        $this->log('warning', 'Utilisateur non trouvé pour le template', [
                            'userId' => $userId,
                            'templateId' => $row['id']
                        ]);
                        
                        // NIVEAU 3: Si nous ne pouvons pas trouver l'utilisateur, créer un proxy
                        $userProxy = new \App\Entities\User();
                        $userIdProperty = new \ReflectionProperty(\App\Entities\User::class, 'id');
                        $userIdProperty->setAccessible(true);
                        $userIdProperty->setValue($userProxy, $userId);
                        
                        $template->setUser($userProxy);
                    }

                    // Gérer les dates
                    $createdAt = $reflectionClass->getProperty('createdAt');
                    $createdAt->setAccessible(true);
                    $createdAt->setValue($template, new \DateTime($row['createdAt']));

                    $updatedAt = $reflectionClass->getProperty('updatedAt');
                    $updatedAt->setAccessible(true);
                    $updatedAt->setValue($template, new \DateTime($row['updatedAt']));

                    $templates[] = $template;
                }

                return $templates;
            }
        } catch (\Exception $e) {
            // Logguer l'erreur
            $this->log('error', 'Exception dans WhatsAppUserTemplateRepository.findByUser', [
                'userId' => $userId,
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString()
            ]);
            
            // NIVEAU 4: Dernier recours - Vérifier directement dans la base et remonter des objets minimaux
            try {
                $this->log('debug', 'Tentative de récupération de dernier recours');
                $conn = $this->getEntityManager()->getConnection();
                
                // Vérifier si des templates existent
                $count = $conn->fetchOne(
                    'SELECT COUNT(*) FROM whatsapp_user_templates WHERE user_id = ?', 
                    [$userId]
                );
                
                if ($count > 0) {
                    $this->log('info', 'Templates trouvés lors de la vérification de dernier recours', ['count' => $count]);
                    $rows = $conn->fetchAllAssociative(
                        'SELECT id, user_id, template_name, language_code FROM whatsapp_user_templates WHERE user_id = ? LIMIT ?', 
                        [$userId, $limit]
                    );
                    
                    $templates = [];
                    foreach ($rows as $row) {
                        $template = new WhatsAppUserTemplate();
                        $reflectionClass = new \ReflectionClass(WhatsAppUserTemplate::class);

                        // Définir les propriétés minimales nécessaires
                        $idProperty = $reflectionClass->getProperty('id');
                        $idProperty->setAccessible(true);
                        $idProperty->setValue($template, (int)$row['id']);
                        
                        $template->setTemplateName($row['template_name']);
                        $template->setLanguageCode($row['language_code']);
                        
                        // Créer un proxy utilisateur minimal
                        $userProxy = new \App\Entities\User();
                        $userIdProperty = new \ReflectionProperty(\App\Entities\User::class, 'id');
                        $userIdProperty->setAccessible(true);
                        $userIdProperty->setValue($userProxy, (int)$row['user_id']);
                        
                        $template->setUser($userProxy);
                        
                        $templates[] = $template;
                    }
                    
                    return $templates;
                }
            } catch (\Exception $innerE) {
                $this->log('error', 'Échec de la tentative de dernier recours', [
                    'error' => $innerE->getMessage()
                ]);
            }
            
            // Retourner un tableau vide en cas d'erreur complète
            return [];
        }
    }

    /**
     * Trouve un template par son utilisateur, nom et code de langue
     *
     * @param int $userId
     * @param string $templateName
     * @param string $languageCode
     * @return \App\Entities\WhatsApp\WhatsAppUserTemplate|null
     */
    public function findByUserAndNameAndLanguage(int $userId, string $templateName, string $languageCode): ?\App\Entities\WhatsApp\WhatsAppUserTemplate
    {
        try {
            $this->log('debug', 'Recherche de template par user/nom/langue', [
                'userId' => $userId,
                'templateName' => $templateName,
                'languageCode' => $languageCode
            ]);
            
            $queryBuilder = $this->getEntityManager()->createQueryBuilder();

            return $queryBuilder->select('t')
                ->from(WhatsAppUserTemplate::class, 't')
                ->join('t.user', 'u')
                ->where('u.id = :userId')
                ->andWhere('t.templateName = :templateName')
                ->andWhere('t.languageCode = :languageCode')
                ->setParameter('userId', $userId)
                ->setParameter('templateName', $templateName)
                ->setParameter('languageCode', $languageCode)
                ->getQuery()
                ->getOneOrNullResult();
        } catch (\Exception $e) {
            $this->log('error', 'Erreur lors de la recherche de template par user/nom/langue', [
                'userId' => $userId,
                'templateName' => $templateName,
                'languageCode' => $languageCode,
                'error' => $e->getMessage()
            ]);
            
            // En cas d'erreur, essayons avec SQL direct
            try {
                $conn = $this->getEntityManager()->getConnection();
                $result = $conn->fetchAssociative('
                    SELECT
                        id, user_id, template_name, language_code, body_variables_count,
                        has_header_media, is_special_template, header_media_url, created_at, updated_at
                    FROM whatsapp_user_templates
                    WHERE user_id = ? AND template_name = ? AND language_code = ?
                ', [$userId, $templateName, $languageCode]);
                
                if ($result) {
                    // Construire un objet à partir du résultat SQL
                    $template = new WhatsAppUserTemplate();
                    $reflectionClass = new \ReflectionClass(WhatsAppUserTemplate::class);
                    
                    $idProperty = $reflectionClass->getProperty('id');
                    $idProperty->setAccessible(true);
                    $idProperty->setValue($template, (int)$result['id']);
                    
                    $template->setTemplateName($result['template_name'])
                        ->setLanguageCode($result['language_code'])
                        ->setBodyVariablesCount($result['body_variables_count'] !== null ? (int)$result['body_variables_count'] : null)
                        ->setHasHeaderMedia((bool)$result['has_header_media'])
                        ->setIsSpecialTemplate((bool)$result['is_special_template'])
                        ->setHeaderMediaUrl($result['header_media_url']);
                    
                    // Créer l'utilisateur et le lier
                    $userRepository = $this->getEntityManager()->getRepository(\App\Entities\User::class);
                    $user = $userRepository->find($userId);
                    if ($user) {
                        $template->setUser($user);
                    } else {
                        // Si l'utilisateur n'est pas trouvé, créer un proxy
                        $userProxy = new \App\Entities\User();
                        $userIdProperty = new \ReflectionProperty(\App\Entities\User::class, 'id');
                        $userIdProperty->setAccessible(true);
                        $userIdProperty->setValue($userProxy, $userId);
                        $template->setUser($userProxy);
                    }
                    
                    // Dates
                    $createdAt = $reflectionClass->getProperty('createdAt');
                    $createdAt->setAccessible(true);
                    $createdAt->setValue($template, new \DateTime($result['created_at']));
                    
                    $updatedAt = $reflectionClass->getProperty('updatedAt');
                    $updatedAt->setAccessible(true);
                    $updatedAt->setValue($template, new \DateTime($result['updated_at']));
                    
                    return $template;
                }
                
                return null;
            } catch (\Exception $sqlException) {
                $this->log('error', 'Échec également de la recherche SQL directe', [
                    'error' => $sqlException->getMessage()
                ]);
                return null;
            }
        }
    }

    /**
     * Compte le nombre de templates pour un utilisateur
     *
     * @param int $userId
     * @return int
     */
    public function countByUser(int $userId): int
    {
        try {
            $queryBuilder = $this->getEntityManager()->createQueryBuilder();

            return $queryBuilder->select('COUNT(t.id)')
                ->from(WhatsAppUserTemplate::class, 't')
                ->join('t.user', 'u')
                ->where('u.id = :userId')
                ->setParameter('userId', $userId)
                ->getQuery()
                ->getSingleScalarResult();
        } catch (\Exception $e) {
            $this->log('error', 'Erreur lors du comptage des templates', [
                'userId' => $userId,
                'error' => $e->getMessage()
            ]);
            
            // Essayer SQL direct en cas d'erreur
            try {
                $conn = $this->getEntityManager()->getConnection();
                return (int)$conn->fetchOne(
                    'SELECT COUNT(*) FROM whatsapp_user_templates WHERE user_id = ?',
                    [$userId]
                );
            } catch (\Exception $sqlException) {
                $this->log('error', 'Échec également du comptage SQL direct', [
                    'error' => $sqlException->getMessage()
                ]);
                return 0;
            }
        }
    }

    /**
     * Supprime un template
     *
     * @param mixed $entity Le template ou l'entité à supprimer
     * @return bool
     */
    public function delete($entity): bool
    {
        try {
            if (!$entity instanceof WhatsAppUserTemplate) {
                throw new InvalidArgumentException('Expected instance of WhatsAppUserTemplate');
            }
            $this->getEntityManager()->remove($entity);
            $this->getEntityManager()->flush();
            return true;
        } catch (\Exception $e) {
            $this->log('error', 'Erreur lors de la suppression du template', [
                'id' => $entity instanceof WhatsAppUserTemplate ? $entity->getId() : 'unknown',
                'error' => $e->getMessage()
            ]);
            return false;
        }
    }

    /**
     * Retourne le nom de la classe d'entité gérée par ce repository
     *
     * @return string Le nom de la classe d'entité
     */
    public function getEntityClassName(): string
    {
        return WhatsAppUserTemplate::class;
    }

    /**
     * Recherche des entités selon des critères spécifiques
     *
     * @param array $criteria Les critères de recherche
     * @param array|null $orderBy Tri des résultats
     * @param int|null $limit Limite le nombre d'entités retournées
     * @param int|null $offset Décalage pour la pagination
     * @return array Les entités trouvées
     */
    public function findBy(array $criteria, ?array $orderBy = null, ?int $limit = null, ?int $offset = null): array
    {
        try {
            $queryBuilder = $this->getEntityManager()->createQueryBuilder();
            $queryBuilder->select('t')
                ->from(WhatsAppUserTemplate::class, 't');

            // Ajouter les critères de recherche
            $i = 0;
            foreach ($criteria as $field => $value) {
                // Gérer le cas spécial du userId qui doit être mappé à la relation user
                if ($field === 'userId') {
                    $queryBuilder->join('t.user', 'u')
                        ->andWhere('u.id = :userId')
                        ->setParameter('userId', $value);
                } else {
                    $param = 'param' . $i;
                    $queryBuilder->andWhere("t.$field = :$param")
                        ->setParameter($param, $value);
                    $i++;
                }
            }

            // Ajouter l'ordre de tri
            if ($orderBy) {
                foreach ($orderBy as $field => $order) {
                    $queryBuilder->addOrderBy("t.$field", $order);
                }
            } else {
                // Tri par défaut par date de création décroissante
                $queryBuilder->orderBy('t.createdAt', 'DESC');
            }

            // Ajouter la limite et l'offset
            if ($limit !== null) {
                $queryBuilder->setMaxResults($limit);
            }

            if ($offset !== null) {
                $queryBuilder->setFirstResult($offset);
            }

            return $queryBuilder->getQuery()->getResult();
        } catch (\Exception $e) {
            $this->log('error', 'Erreur lors de la recherche avec critères', [
                'criteria' => json_encode($criteria),
                'error' => $e->getMessage()
            ]);
            
            // Essayer SQL direct pour les cas simples
            if (isset($criteria['userId']) && count($criteria) === 1) {
                try {
                    return $this->findByUser($criteria['userId'], $limit ?? 50, $offset ?? 0);
                } catch (\Exception $fallbackException) {
                    $this->log('error', 'Erreur lors du fallback findByUser', [
                        'error' => $fallbackException->getMessage()
                    ]);
                }
            }
            
            return [];
        }
    }

    /**
     * Trouve une seule entité selon des critères spécifiques
     *
     * @param array $criteria Les critères de recherche
     * @param array|null $orderBy Tri des résultats
     * @return WhatsAppUserTemplate|null L'entité trouvée ou null si non trouvée
     */
    public function findOneBy(array $criteria, ?array $orderBy = null): ?WhatsAppUserTemplate
    {
        try {
            $queryBuilder = $this->getEntityManager()->createQueryBuilder();
            $queryBuilder->select('t')
                ->from(WhatsAppUserTemplate::class, 't');

            // Ajouter les critères de recherche
            $i = 0;
            foreach ($criteria as $field => $value) {
                // Gérer le cas spécial du userId qui doit être mappé à la relation user
                if ($field === 'userId') {
                    $queryBuilder->join('t.user', 'u')
                        ->andWhere('u.id = :userId')
                        ->setParameter('userId', $value);
                } else {
                    $param = 'param' . $i;
                    $queryBuilder->andWhere("t.$field = :$param")
                        ->setParameter($param, $value);
                    $i++;
                }
            }

            // Ajouter l'ordre de tri
            if ($orderBy) {
                foreach ($orderBy as $field => $order) {
                    $queryBuilder->addOrderBy("t.$field", $order);
                }
            }

            // Limiter à un seul résultat
            $queryBuilder->setMaxResults(1);

            return $queryBuilder->getQuery()->getOneOrNullResult();
        } catch (\Exception $e) {
            $this->log('error', 'Erreur lors de la recherche d\'une entité avec critères', [
                'criteria' => json_encode($criteria),
                'error' => $e->getMessage()
            ]);
            
            // Cas spécial pour recherche par userId, templateName et languageCode
            if (isset($criteria['userId']) && isset($criteria['templateName']) && isset($criteria['languageCode'])) {
                try {
                    return $this->findByUserAndNameAndLanguage(
                        (int)$criteria['userId'],
                        $criteria['templateName'],
                        $criteria['languageCode']
                    );
                } catch (\Exception $fallbackException) {
                    $this->log('error', 'Erreur lors du fallback findByUserAndNameAndLanguage', [
                        'error' => $fallbackException->getMessage()
                    ]);
                }
            }
            
            return null;
        }
    }

    /**
     * Sauvegarde plusieurs entités en une seule opération
     * 
     * @param array $entities Les entités à sauvegarder
     * @return array Les entités sauvegardées
     */
    public function saveMany(array $entities): array
    {
        $this->getEntityManager()->beginTransaction();
        
        try {
            foreach ($entities as $entity) {
                if (!$entity instanceof WhatsAppUserTemplate) {
                    throw new InvalidArgumentException('Expected instance of WhatsAppUserTemplate');
                }
                $this->getEntityManager()->persist($entity);
            }

            $this->getEntityManager()->flush();
            $this->getEntityManager()->commit();
            
            return $entities;
        } catch (\Exception $e) {
            $this->getEntityManager()->rollback();
            $this->log('error', 'Erreur lors de la sauvegarde multiple de templates', [
                'count' => count($entities),
                'error' => $e->getMessage()
            ]);
            
            throw $e;
        }
    }

    /**
     * Supprime plusieurs entités en une seule opération
     *
     * @param array $entities Les entités à supprimer
     * @return bool
     */
    public function deleteMany(array $entities): bool
    {
        $this->getEntityManager()->beginTransaction();
        
        try {
            foreach ($entities as $entity) {
                if (!$entity instanceof WhatsAppUserTemplate) {
                    throw new InvalidArgumentException('Expected instance of WhatsAppUserTemplate');
                }
                $this->getEntityManager()->remove($entity);
            }

            $this->getEntityManager()->flush();
            $this->getEntityManager()->commit();
            
            return true;
        } catch (\Exception $e) {
            $this->getEntityManager()->rollback();
            $this->log('error', 'Erreur lors de la suppression multiple de templates', [
                'count' => count($entities),
                'error' => $e->getMessage()
            ]);
            
            return false;
        }
    }

    /**
     * Recherche des templates par une requête textuelle
     *
     * @param string $query La requête de recherche
     * @param array|null $fields Les champs dans lesquels rechercher
     * @param int|null $limit Limite de résultats
     * @param int|null $offset Décalage pour la pagination
     * @return array
     */
    public function search(string $query, ?array $fields = null, ?int $limit = null, ?int $offset = null): array
    {
        try {
            $queryBuilder = $this->getEntityManager()->createQueryBuilder();
            $queryBuilder->select('t')
                ->from(WhatsAppUserTemplate::class, 't');

            // Déterminer les champs de recherche
            if ($fields === null || empty($fields)) {
                // Par défaut, chercher dans le nom du template et le code de langue
                $fields = ['templateName', 'languageCode'];
            }

            // Construire la condition de recherche
            $conditions = [];
            $parameters = [];

            foreach ($fields as $i => $field) {
                $paramName = 'query' . $i;
                $conditions[] = "t.$field LIKE :$paramName";
                $parameters[$paramName] = '%' . $query . '%';
            }

            if (!empty($conditions)) {
                $queryBuilder->andWhere('(' . implode(' OR ', $conditions) . ')');

                // Ajouter les paramètres à la requête
                foreach ($parameters as $name => $value) {
                    $queryBuilder->setParameter($name, $value);
                }
            }

            // Tri par défaut par date de création décroissante
            $queryBuilder->orderBy('t.createdAt', 'DESC');

            // Ajouter la limite et l'offset
            if ($limit !== null) {
                $queryBuilder->setMaxResults($limit);
            }

            if ($offset !== null) {
                $queryBuilder->setFirstResult($offset);
            }

            return $queryBuilder->getQuery()->getResult();
        } catch (\Exception $e) {
            $this->log('error', 'Erreur lors de la recherche textuelle de templates', [
                'query' => $query,
                'fields' => json_encode($fields ?? []),
                'error' => $e->getMessage()
            ]);
            
            // SQL direct pour la recherche simple
            try {
                $conn = $this->getEntityManager()->getConnection();
                
                $fieldList = $fields ?? ['template_name', 'language_code'];
                $sqlFields = [];
                foreach ($fieldList as $field) {
                    // Convertir camelCase en snake_case pour SQL
                    $sqlField = strtolower(preg_replace('/([a-z])([A-Z])/', '$1_$2', $field));
                    $sqlFields[] = "$sqlField LIKE ?";
                }
                
                $whereClause = '(' . implode(' OR ', $sqlFields) . ')';
                $params = array_fill(0, count($sqlFields), '%' . $query . '%');
                
                if ($limit !== null) {
                    $params[] = $limit;
                    $limitClause = 'LIMIT ?';
                } else {
                    $limitClause = '';
                }
                
                if ($offset !== null) {
                    $params[] = $offset;
                    $offsetClause = 'OFFSET ?';
                } else {
                    $offsetClause = '';
                }
                
                $sql = "SELECT * FROM whatsapp_user_templates WHERE $whereClause ORDER BY created_at DESC $limitClause $offsetClause";
                $results = $conn->fetchAllAssociative($sql, $params);
                
                // Transformer en objets
                $templates = [];
                foreach ($results as $row) {
                    $template = new WhatsAppUserTemplate();
                    $reflectionClass = new \ReflectionClass(WhatsAppUserTemplate::class);
                    
                    $idProperty = $reflectionClass->getProperty('id');
                    $idProperty->setAccessible(true);
                    $idProperty->setValue($template, (int)$row['id']);
                    
                    $template->setTemplateName($row['template_name'])
                        ->setLanguageCode($row['language_code'])
                        ->setBodyVariablesCount($row['body_variables_count'] !== null ? (int)$row['body_variables_count'] : null)
                        ->setHasHeaderMedia((bool)$row['has_header_media'])
                        ->setIsSpecialTemplate((bool)$row['is_special_template'])
                        ->setHeaderMediaUrl($row['header_media_url']);
                    
                    // Utilisateur
                    $userRepository = $this->getEntityManager()->getRepository(\App\Entities\User::class);
                    $user = $userRepository->find($row['user_id']);
                    if ($user) {
                        $template->setUser($user);
                    } else {
                        $userProxy = new \App\Entities\User();
                        $userIdProperty = new \ReflectionProperty(\App\Entities\User::class, 'id');
                        $userIdProperty->setAccessible(true);
                        $userIdProperty->setValue($userProxy, (int)$row['user_id']);
                        $template->setUser($userProxy);
                    }
                    
                    // Dates
                    $createdAt = $reflectionClass->getProperty('createdAt');
                    $createdAt->setAccessible(true);
                    $createdAt->setValue($template, new \DateTime($row['created_at']));
                    
                    $updatedAt = $reflectionClass->getProperty('updatedAt');
                    $updatedAt->setAccessible(true);
                    $updatedAt->setValue($template, new \DateTime($row['updated_at']));
                    
                    $templates[] = $template;
                }
                
                return $templates;
            } catch (\Exception $sqlException) {
                $this->log('error', 'Échec également de la recherche SQL directe', [
                    'error' => $sqlException->getMessage()
                ]);
                return [];
            }
        }
    }
}